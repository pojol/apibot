# Edit (编辑页

> 编辑行为树的视窗

![img](../../res/edit.png)

## 节点区域
> 按住节点向编辑区域拖拽创建新的节点
* **Control** - 控制节点，主要用于控制行为树的节点运行逻辑
  * **Sequence** 依次运行该节点下的所有子节点
  * **Selector** 执行此节点下的所有节点，当子节点执行成功时退出此节点

* **Condition** - 判定节点，用于节点的条件判定 （脚本节点
  * **Condition** 使用表达式判断是否向下执行
  * **Assert** 使用表达式判断是否中断执行

* **Script** - 脚本节点, 用于进行bot的具体动作
  * **Action** 动作节点，执行预设的lua脚本

* **Decorator** - 装饰节点
  * **Loop** 设置该节点下所有子节点的循环次数
  * **Wait** 设置当前节点阻塞若干时间（毫秒

## 编辑区域
> 通过连线构建出行为树，有先后关系（在Sequence节点下，先连接的先执行
* **选中状态**
  * 当节点被点击，边框有虚线包裹时代表该节点处于选中状态（同时能在脚本区看到节点的ID），只有选中状态的节点才可以进行内容的编辑
* **连线的规则**
  * Control 类型的节点可以同时指向多个子节点，其他的节点只能存在一条线段，代表由父节点指向子节点
* **删除节点**
  * 快捷键 Del 可以删除节点

## 脚本区域
> 编辑节点的属性，并应用到行为树中
* **页签** - 当编辑区的节点被选中时，会自动切换到对应类型的编辑页签
* **ID** - 左下角的 uuid 代表这个节点的唯一id
* **Apply** - 应用节点的编辑改动
* **Alias** - 设置节点的别名（会显示在编辑视图的节点上
* **Script** - lua脚本编辑窗口，脚本会在执行到此节点时被驱动层执行

#### **-- Script --**
* 脚本模板
  - 在 config 页中可以配置默认的 scrpit 区域模板代码
* 入口函数
  - 驱动层会在加载机器人时将所需的脚本都装载进来，一个机器人将拥有一个属于自己的VM
  - 当执行到具体的Script节点时，会装载该脚本并调用入口函数 `execute`
* 脚本内置的接口
  - 驱动层提供了一些默认的脚本接口 [script interface](../advance/script.md)

## 调试区域
> 获取远程行为树节点返回的结果
* **Create** - 基于当前编辑窗口创建一个零时的行为树实例
* **Step** - 基于当前零时的行为树实例，步进一次
* **Json 视窗** - 获取机器人当前的 meta 数据

#### **-- Debug --**
* Meta 数据
  - meta 数据包含了这个机器人所有的本地数据，在脚本中通过 meta.XXX 进行访问
  - 数据覆盖，在默认的脚本模板中，我们采用了覆盖（`merge` 的方式将每次服务器的返回数据解析成json结构后，覆盖进meta （如果存在则覆盖到最新，如果没有则创建新的键
* 捕捉错误
  - 通过 meta 的机制，我们可以在脚本层的 meta 中自定义一个 Err 的字段，将脚本中的错误输出到这个键上，这样在执行到该节点的时候，就能看到相关的信息
